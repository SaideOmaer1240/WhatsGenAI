/home/saide/WhatsGenAI/backend/index.ts
    import dotenv from 'dotenv';
    import qrcode from 'qrcode';
    import express, { Request, Response, NextFunction } from 'express';
    import cors from 'cors';
    import { PrismaClient } from '@prisma/client';
    import { Server } from 'socket.io';
    import bcrypt from 'bcrypt';
    import Joi from 'joi';

    import initSessions from './src/utils/initSession';
    import createSession from './src/utils/createSession';
    import { authenticateToken } from './src/auth/middleware';
    import { generateToken } from './src/auth/genToken';
    import Seller from './src/seller/Seller';

    // Carrega variáveis de ambiente
    dotenv.config();

    // Esquema de validação de sessão
    const sessionSchema = Joi.object({
        sessionId: Joi.string().required(),
        userId: Joi.number().integer().required(),
    });

    // Inicialização de instâncias
    const prisma = new PrismaClient();
    const sellerController = new Seller();
    const app = express();
    const PORT = process.env.PORT || 3000;

    // Configuração de CORS
    const corsOptions = {
        origin: process.env.CORS_ORIGIN || 'http://localhost:5173',
        methods: ['GET', 'POST'],
    };
    app.use(cors(corsOptions));

    // Middleware para lidar com erros globais
    app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
        console.error(err.stack);
        res.status(500).json({ error: 'Erro interno do servidor.', details: err.message });
    });

    // Middleware para lidar com JSON
    app.use(express.json());

    // Inicia o servidor
    const server = app.listen(PORT, () => {
        console.log(`Servidor rodando na porta ${PORT}`);
    });

    // Configuração do Socket.io
    const io = new Server(server, {
        cors: {
            origin: '*',
            methods: ['GET', 'POST'],
        },
    });

    // Objetos globais para sessões e vendedores
    const sessions: Record<string, any> = {};
    const sellers: Array<any> = [];

    // Endpoints da API

    // Verificar autenticação
    app.get('/api/check-auth', authenticateToken, (req: Request, res: Response) => {
        res.status(200).json({ authenticated: true, userId: (req as any).userId });
    });

    // Cadastro de usuário
    app.post('/api/register', async (req: Request, res: Response) => {
        const { username, email, password, phoneNumber } = req.body;

        try {
            const hashedPassword = await bcrypt.hash(password, 10);
            const user = await prisma.user.create({
                data: { username, email, password: hashedPassword, phoneNumber },
            });
            res.status(201).json(user);
        } catch (error: any) {
            res.status(400).json({ error: 'Erro ao cadastrar usuário.', details: error.message });
        }
    });

    // Login de usuário
    app.post('/api/login', async (req: Request, res: Response) => {
        const { email, password } = req.body;

        try {
            const user = await prisma.user.findUnique({ where: { email } });

            if (!user || !(await bcrypt.compare(password, user.password))) {
                return res.status(401).json({ error: 'Credenciais inválidas.' });
            }

            const token = generateToken(user.id);
            res.status(200).json({ token, user });
        } catch (error: any) {
            res.status(500).json({ error: 'Erro ao realizar login.', details: error.message });
        }
    });

    // Logout do usuário
    app.post('/api/logout', (_req: Request, res: Response) => {
        res.status(200).json({ message: 'Logout realizado com sucesso.' });
    });

    // Criar uma nova sessão para um usuário
    app.post('/api/create-session', async (req: Request, res: Response) => {
        const { error } = sessionSchema.validate(req.body);
        if (error) return res.status(400).json({ error: error.details[0].message });

        const { sessionId, userId } = req.body;

        if (!sessionId || !userId) {
            return res.status(400).json({ error: 'sessionId e userId são obrigatórios.' });
        }

        if (sessions[sessionId]) {
            return res.status(400).json({ error: 'Sessão já existe.' });
        }

        const user = await prisma.user.findUnique({ where: { id: userId } });
        if (!user) {
            return res.status(404).json({ error: 'Usuário não encontrado.' });
        }

        createSession(sessionId, userId, sessions, io);
        res.status(200).json({ message: 'Sessão criada. Aguarde o QR code.' });
    });

    // Listar vendedores por sessão
    app.get('/api/sellers/:sessionId', async (req: Request, res: Response, next: NextFunction) => {
        const { sessionId } = req.params;
        try {
            const sellers = await sellerController.findSeller(sessionId);
            res.status(200).json(sellers);
        } catch (error) {
            next(error);
        }
    });

    // Obter QR Code de uma sessão
    app.get('/api/get-qr/:sessionId', async (req: Request, res: Response) => {
        const { sessionId } = req.params;

        if (!sessions[sessionId]) {
            return res.status(404).json({ error: 'Sessão não encontrada.' });
        }

        const { qr, ready } = sessions[sessionId];
        if (ready) {
            return res.status(400).json({ error: 'Sessão já conectada.' });
        }

        if (!qr) {
            return res.status(400).json({ error: 'QR Code ainda não gerado. Tente novamente.' });
        }

        const qrImage = await qrcode.toDataURL(qr);
        res.status(200).json({ qrCode: qrImage });
    });

    // Inicializar sessões
    initSessions(sessions, io);